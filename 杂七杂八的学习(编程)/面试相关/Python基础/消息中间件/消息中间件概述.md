[toc]



## 初识

### 消息中间件概述

消息中间件 = 消息队列 = MQ

生产者，消息队列，消费者

生产者将需要处理的发送到消息队列，消费者从中取出

![image-20200920184210058](C:\Users\UncleDong\AppData\Roaming\Typora\typora-user-images\image-20200920184210058.png)



#### 应用场景

##### 异步通信

发邮件，发完邮件就可以去干别的了，不用等邮件回复。回复后我们查看一下就行了。

同步通信：打电话，过程不能被打断，一方挂断电话就会立刻中断通信过程。

适合耗时，不需要立刻反馈的操作

##### 应用解耦

由于引入中间节点，就适合用来解耦

耦合：依赖性，两个对象或者程序之间存在依赖关系

解耦合就是减少模块间的相互关系

消息队列两个方面的解耦

- 消息的生产者和消费者都不需要关心对方的状态，他们唯一需要关心的只是消息的格式
- 消息的 只和中间件通信，接口统一，单方面的拓扑变化不会影响对方

##### 缓解流量高峰压力

促销的时候，流量峰值大于系统并发能力，消息就可以暂时缓存在消息队列中，而不会影响用户的响应时间

### 消息中间件应用场景

日志分析报警系统

![image-20200920193116984](C:\Users\UncleDong\AppData\Roaming\Typora\typora-user-images\image-20200920193116984.png)

一部分在日志存储中，比如数据库

另一部分在实时检测

第一个消息队列在日志采集之后，使得日志分析和日志存储**<u>解耦合</u>**，使得异常分析模块在升级、停止运行的时候，日志存储也会继续进行。

日志存储就是文件读写，相对简单，而异常分析则较为复杂，物理性能远远低于采集模块。但是日志不会时时刻刻产生 。所以消息队列也起到了**<u>平衡模块处理能力</u>**的作用



第二个消息队列在异常分析之后。分析完成之后没有必要等待报警通知后在进行下一次分析，我们只用把报警信息写入消息队列即可。报警模块会在适当的时机自己完成报警。**<u>体现了异步通信</u>**



互联网公司都会有日志处理平台



消息中间件一般是7*24小时不间断运行的，因此要求严格

- 高性能 High Performance 每秒写入的多
- 高可用 High Availability 部分故障，整体还能使用
- 横向扩展 Scale Out 增加服务器数量，提升性能

纵向扩展指的是提升每个服务器的性能，从而提升总体的

但是服务器性能不能无限提升，而且相比之下，网络开销是分布式系统最大的瓶颈，因此横向扩展的上限比较大，集群总是能很方便的添加服务器。



### 常用消息中间件比较

#### 常用消息中间件介绍

- Redis

  轻量级消息消息队列，经常在某个模块的内部使用，缓冲数据量相对较小的数据集

- RabbitMQ

- RocketMQ

- ZeroMQ

- Kafka 

  出色的性能和稳定性 消息可以被多个消费者重复消费，因此经常用于大型系统的消息中转站。里面存放的是未经加工的最原始的数据。不同的业务模块根据自己的业务模型，从中提取最适合的数据进行进一步处理

实际中开源的消息中间件很多，适合不同的应用。

充分了解很多消息中间件后才能找到最适合自己业务场景的消息中间件。

#### 常用消息中间件对比

选择消息中间件的时候会考虑的东西

- 实现预言

  每个团队都有自己最擅长的技能树。服务器端通常只有一个消息引擎。如果对该语言熟悉，我们可以看源代码定位和解决问题。

- 对外接口

  很多模块都会有Http的Rest接口。http的接口在搭建原型和调试验证的时候都很迅速开发也很便捷

- 持久化策略

  和消息的存储方式和消息队列崩溃后是否会丢失消息相关

  如果一个中间件不支持持久化，就得慎重的选择它

- 消息处理模式

  消息的消费模式，消费者是主动接受消息还是服务器主动向消费者发送消息

- 时序保证

  如金融转账的业务

![image-20200920200836952](C:\Users\UncleDong\AppData\Roaming\Typora\typora-user-images\image-20200920200836952.png)



Redis可以到磁盘上，主要是Push-pull，消费者可以主动拉取数据，服务器也可以用Pub-Sub主动通知。内部是队列实现的，可以保证消息的先进先出。



Rabblit这个语言主要用来开发并发和分布式系统，处理模式是push和pull，不过通常只用push，主动把消息投递给消费者，消息能够更加实时





同队列有序：FIFO





#### Push vs Pull

##### Push

Push即服务端主动发送数据给客户端。在服务端收到消息之后立即推送给客户端。

Push模型最大的好处就是实时性。因为服务端可以做到只要有消息就立即推送，所以消息的消费没有“额外”的延迟。

但是Push模式在消息中间件的场景中会面临以下一些问题：

- 在Broker端需要维护Consumer的状态，不利于Broker去支持大量的Consumer的场景
- Consumer的消费速度是不一致的，由Broker进行推送难以处理不同的Consumer的状况
- Broker难以处理Consumer无法消费消息的情况（Broker无法确定Consumer的故障是短暂的还是永久的）
- 大量的推送消息会加重Consumer的负载或者冲垮Consumer

Pull模式可以很好的应对以上的这些场景。

##### Pull

Pull模式由Consumer主动从Broker获取消息。

这样带来了一些好处：

- Broker不再需要维护Consumer的状态（每一次pull都包含了其实偏移量等必要的信息）
- 状态维护在Consumer，所以Consumer可以很容易的根据自身的负载等状态来决定从Broker获取消息的频率

> Pull模式还有一个好处是可以聚合消息。 因为Broker无法预测写一条消息产生的时间，所以在收到消息之后只能立即推送给Consumer，所以无法对消息聚合后再推送给Consumer。 而Pull模式由Consumer主动来获取消息，每一次Pull时都尽可能多的获取已近在Broker上的消息。